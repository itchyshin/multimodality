---
title: "**Integration of multimodal cues does not alter mean but reduces variance in avian responses to predators: a systematic review and meta-analysis**"
subtitle: "**Supplmentary Material**"
author: "**Kim + Shinichi et al.**"
date: "`r Sys.Date()`"
format:
  html:
    toc: true
    toc-location: left
    toc-depth: 3
    toc-title: "**Table of Contents**"
    output-file: "index.html"
    theme: simplex
    embed-resources: true
    code-fold: true
    code-tools: true
    number-sections: true
    #bibliography: ./bib/ref.bib
    fontsize: "12"
    max-width: "10"
    code-overflow: wrap
crossref: 
  fig-title: Figure     # (default is "Figure")
  tbl-title: Table     # (default is "Table")
  title-delim: â€”     # (default is ":")
  fig-prefix: Fig.   # (default is "Figure")
  tbl-prefix: Tab.    # (default is "Table")
editor_options: 
  chunk_output_type: console
execute:
  warning: false
  message: false
  tidy: true
  #cache: true
---

## Setting up

### Loading packages

```{r}
# install.packages("pacman")
# pacman::p_load(devtools, tidyverse, metafor, patchwork, R.rsp, emmeans)
# devtools::install_github("daniel1noble/orchaRd", force = TRUE)

# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("ggtree")

library(pacman)

p_load(
    tidyverse,
    here,
    #lme4,
    orchaRd,
    metafor,
    patchwork,
    alluvial,
    ggalluvial,
    ape,
    #easyalluvial,
    clubSandwich,
    emmeans,
    MuMIn,
    kableExtra,
    pander,
    parallel,
    miWQS, # for Rubin's rules
    ggtree,
    ggstance,
    readxl,
    maps,
    ggthemes,
    cowplot,
    png,
    grid,
    raster,
    magick,
    purrr
)

# making metafor talk to MuMIn
eval(metafor:::.MuMIn)
```

### Getting data loaded

```{r}
dat_full <- read.csv(here("data/dat_19_07_2023_spp.csv"))
meta_dat <- read.csv(here("data/Meta-data.csv"))

# we can do 50 different trees as in 
# https://academic.oup.com/sysbio/article/68/4/632/5267840
tree_50 <- readRDS(here("tree/tree_50.RDS"))

tree <- tree_50[[1]]
#plot(tree)
# turning it into a correlation matrix
cor_tree <- vcv(tree, corr=T)

```

### Raw data and meta-data

```{r}
# making a scrollable table
kable(dat_full, "html", escape = FALSE) %>% kable_styling("striped", position = "left", full_width = TRUE) %>% 
  column_spec(66, width_min = "5in") %>% 
  scroll_box(width = "100%", 
    height = "500px")

# meta-data for it
kable(meta_dat, "html", escape = FALSE) %>% kable_styling("striped", position = "left", full_width = TRUE) %>% 
   column_spec(2, width_min = "3in") %>% 
   column_spec(3, width_min = "6in") %>% 
  scroll_box(width = "100%", 
    height = "500px")
```
### Custom functions

We have 5 custom functions named : `cont_gen()`,`get_pred1()`, `get_pred2()`, `mr_results()`, and `all_models()`, all of which are used later (see below for their functionality) and the code is included here.


```{r}
# custom functions

#' Title: Contrast name generator
#'
#' @param name: a vector of character strings
cont_gen <- function(name) {
  combination <- combn(name, 2)
  name_dat <- t(combination)
  names <- paste(name_dat[, 1], name_dat[, 2], sep = "-")
  return(names)
}

#' @title get_pred1: intercept-less model
#' @description Function to get CIs (confidence intervals) and PIs (prediction intervals) from rma objects (metafor)
#' @param model: rma.mv object 
#' @param mod: the name of a moderator 
get_pred1 <- function (model, mod = " ") {
  name <- firstup(as.character(stringr::str_replace(row.names(model$beta), mod, "")))
  len <- length(name)
  
   if (len != 1) {
        newdata <- diag(len)
        pred <- metafor::predict.rma(model, 
                                     newmods = newdata,
                                     tau2.levels = 1:len)
    }
    else {
        pred <- metafor::predict.rma(model)
  }
  estimate <- pred$pred
  lowerCL <- pred$ci.lb
  upperCL <- pred$ci.ub 
  lowerPR <- pred$cr.lb
  upperPR <- pred$cr.ub 
  
  table <- tibble(name = factor(name, levels = name, labels = name), estimate = estimate,
                  lowerCL = lowerCL, upperCL = upperCL,
                  pval = model$pval,
                  lowerPR = lowerPR, upperPR = upperPR)
}

#' @title get_pred2: normal model
#' @description Function to get CIs (confidence intervals) and PIs (prediction intervals) from rma objects (metafor)
#' @param model: rma.mv object 
#' @param mod: the name of a moderator 
get_pred2 <- function (model, mod = " ") {
  name <- as.factor(str_replace(row.names(model$beta), 
                                paste0("relevel", "\\(", mod,", ref = name",
                                       "\\)"),""))
  len <- length(name)
  
  if(len != 1){
  newdata <- diag(len)
  pred <- predict.rma(model, intercept = FALSE, newmods = newdata[,-1])
  }
  else {
    pred <- predict.rma(model)
  }
  estimate <- pred$pred
  lowerCL <- pred$ci.lb
  upperCL <- pred$ci.ub 
  lowerPR <- pred$cr.lb
  upperPR <- pred$cr.ub 
  
  table <- tibble(name = factor(name, levels = name, labels = name), estimate = estimate,
                  lowerCL = lowerCL, upperCL = upperCL,
                  pval = model$pval,
                  lowerPR = lowerPR, upperPR = upperPR)
}

#' @title mr_results
#' @description Function to put results of meta-regression and its contrasts
#' @param res1: data frame 1
#' @param res1: data frame 2
mr_results <- function(res1, res2) {
  restuls <-tibble(
    `Fixed effect` = c(as.character(res1$name), cont_gen(res1$name)),
    Estimate = c(res1$estimate, res2$estimate),
    `Lower CI [0.025]` = c(res1$lowerCL, res2$lowerCL),
    `Upper CI  [0.975]` = c(res1$upperCL, res2$upperCL),
    `P value` = c(res1$pval, res2$pval),
    `Lower PI [0.025]` = c(res1$lowerPR, res2$lowerPR),
    `Upper PI  [0.975]` = c(res1$upperPR, res2$upperPR),
  )
}


#' @title all_models
#' @description Function to take all possible models and get their results
#' @param model: intercept-less model
#' @param mod: the name of a moderator 

all_models <- function(model, mod = " ", type = "homo") {
  
  # getting the level names out
  level_names <- levels(factor(model$data[[mod]]))
  dat2 <- model$data
  mod <- mod

  VCV1 <- vcalc(vi = dat2$Vd,
             cluster = dat2$SubjectID,
             rho = 0.5)
  #model$data[[mod]] <- factor(model$data[[mod]], ordered = FALSE)
  # meta-regression: contrasts 
  # helper function to run metafor meta-regression
  run_rma1 <- function(name) {
    rma.mv(yi = SMD, 
         V = VCV1, 
         mods = ~ relevel(dat2[[mod]], ref = name), 
         random = list(~1 | Spp,
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat2)
   }

    run_rma2 <- function(name) {
    rma.mv(yi = SMD,
         V = VCV1,
         mods = ~ relevel(dat2[[mod]], ref = name),
         random = list(~1 | Spp,
                             ~1 | RecNo,
                             formula(paste("~", mod, "| Obs_ID"))),
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat2)
   }

  # results of meta-regression including all contrast results; taking the last level out ([-length(level_names)])
  # this does not work for hetero model?
  if (type == "homo"){
  model_all <- purrr::map(level_names[-length(level_names)], run_rma1)
  } else {
  model_all <- purrr::map(level_names[-length(level_names)], run_rma2)
  }
  
  # getting estimates from intercept-less models (means for all the groups)
  res1 <- get_pred1(model, mod = mod)
  
  # getting estiamtes from all contrast models
  res2_pre <- purrr::map(model_all, ~ get_pred2(.x, mod = mod))
  
  # a list of the numbers to take out unnecessary contrasts
  contra_list <- Map(seq, from=1, to=1:(length(level_names) - 1))
  res2 <- map2_dfr(res2_pre, contra_list, ~.x[-(.y), ]) 
  # creating a table
  res_tab <- mr_results(res1, res2) %>% 
  kable("html",  digits = 3) %>%
  kable_styling("striped", position = "left") %>%
  scroll_box(width = "100%")
  
  # results
  res_tab

}

# test 
#all_models(mod1, mod = "Treat_mod")
#all_models(mod1s, mod = "Treat_mod")
#all_models(mod1s2, mod = "Treat_mod")
```

### Preparing data set

```{r}
# function for calculating variance
Vd_func <- function(d, n1, n2, design, r = 0.5){
  # independent design
  if(design == "among"){
    var <- (n1 + n2) / (n1*n2) + d^2 / (2 * (n1 + n2 - 2)) # variance
  } else { # dependent design
    var <- 2*(1-r) / n1 + d^2 / (2*(n1 - 1)) # variance
  }
  var # return variance
}

# getting Hedges' g - get small size bias corrected effect size
dat_full$SMD <- dat_full$d / (1 - 3/(4 * (dat_full$NTreat + dat_full$Ncontrol) - 9))

# flipping d 
dat_full$SMD <- dat_full$d*dat_full$Direction*dat_full$PredictedDirection


# calucating Vd
dat_full$Vd <- with(dat_full, pmap_dbl(list(SMD, NTreat, Ncontrol, Design), Vd_func))


# extra useful function
# function for getting mean and sd from median, quartiles and sample size
# get_mean_sd <- function(median, q1, q3, n){
#   sd <- (q3 - q1) / (2 * (qnorm((0.75 * n - 0.125) / (n + 0.25)))) # sd
#   mean <- (median + q1 + q3)/3 # mean
#   c(mean, sd)
# }


# observation id
dat_full$Obs_ID <- 1:nrow(dat_full)
#dat_full$Phylo <- gsub(" ", "_", dat_full$FocalSpL)

# filtering very large variance and also very small sample size
dat_int <- dat_full %>% filter(Vd < 10 & Ncontrol > 2 & NTreat > 2)

#dim(dat_full)
#dim(dat_int)


# sorting out modality stuff
# creat - 1,2,3 modality - also easier classification A, O, V (AOV = L) 

dat_int %>% mutate(Treat_mod = case_when(Treatment == "A" ~ "A",
                                          Treatment == "AV" ~ "AV",
                                          Treatment == "AVG" ~ "AV",
                                          Treatment == "AVM" ~ "AV",
                                          Treatment == "L" ~ "AVO",
                                          Treatment == "O" ~ "O",
                                          Treatment == "OV" ~ "OV",
                                          Treatment == "V" ~ "V",
                                          Treatment == "VG" ~ "V",
                                          Treatment == "VM" ~ "V",
                                          Treatment == "VP" ~ "V"),
                    # into how many
                    Treat_No = case_when(Treatment == "A" ~ 1,
                                         Treatment == "AV" ~ 2,
                                         Treatment == "AVG" ~ 2,
                                         Treatment == "AVM" ~ 2,
                                         Treatment == "L" ~ 3,
                                         Treatment == "O" ~ 1,
                                         Treatment == "OV" ~ 2,
                                         Treatment == "V" ~ 1,
                                         Treatment == "VG" ~ 1,
                                         Treatment == "VM" ~ 1,
                                         Treatment == "VP" ~ 1),
                    # des it have some add-ons
                    Add_on = case_when(Treatment == "A" ~ "No",
                                         Treatment == "AV" ~ "No",
                                         Treatment == "AVG" ~ "Yes",
                                         Treatment == "AVM" ~ "Yes",
                                         Treatment == "L" ~ "No",
                                         Treatment == "O" ~ "No",
                                         Treatment == "OV" ~ "No",
                                         Treatment == "V" ~ "No",
                                         Treatment == "VG" ~ "Yes",
                                         Treatment == "VM" ~ "Yes",
                                         Treatment == "VP" ~ "Yes"),

                      ) -> dat_int2



dat <- dat_int2 %>%
  mutate_if(is.character, as.factor) %>% 
  mutate(Spp = FocalSpL_corrected,
         Phylo = FocalSpL_corrected) %>% 
  dplyr::select(RecNo, Author, Year, PredGuild, PredTo, Setting, 
         Season, Design, duration_days, ResponsePeriod, 
         ControlType, Sex, Age, NTreat, Ncontrol, 
         SubjectID, Type, Category, Spp, Phylo,
         SMD, Vd, Obs_ID, Treat_mod, Treat_No, Add_on) 


# creating data just for A, V, and AV 
dat_short <- dat %>% filter(Treat_mod == "A" | Treat_mod == "V" | Treat_mod == "AV")

# for add-on, we only need V and AV
dat_short_add <- dat %>% filter(Treat_mod == "AV" | Treat_mod == "V")


# reordering factors for better visualization

dat$Treat_mod <- factor(dat$Treat_mod, levels = rev(c("A", "V", "AV", "O", "OV", "AVO")))
dat$Type <- factor(dat$Type, levels = rev(c("Behaviour", "LifeHistory", "Physiology")))

```

### Processed data

```{r}
# showing processed data table
kable(dat, "html", escape = FALSE, digits = 3) %>% kable_styling("striped", position = "left", full_width = TRUE) %>% 
 # column_spec(66, width_min = "5in") %>% 
  scroll_box(width = "100%", 
    height = "500px")

```

## Exploratory visualization 


For `Treat_mod` (Treatment), we will only visualise `A`, `V`, and `AV` as `O` $r $, `OV`, and `AVO` are much rarer. But for `Type` (Trait type), we will use all data.

::: {.panel-tabset}

## Treatment vs. Trait types
```{r}
# reordering dat_shrot$Treat_mod for better visualisation
dat_short$Treat_mod <- factor(dat_short$Treat_mod, levels = c("A", "V", "AV"))

# Treatment vs Type
dat_short %>% group_by(Treat_mod, Type) %>%
  summarise(n = n()) -> tab

#alluvial(tab1[,1:2], freq = tab1$n)

# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Treat_mod,
           axis2 = Type)) +
  geom_alluvium(aes(fill = Treat_mod)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Treatment modality and trait type")

```

## Treatment vs. Treatment duration
```{r}
# tuning Treatment duration into a binary variable
dat_short %>% mutate(TDuration = case_when(duration_days < 1 ~ "< 1 day",
                                          duration_days >= 1 ~ "> 1 day")) -> dat_short

# reformatting data
dat_short %>% group_by(Treat_mod, TDuration) %>%
  summarise(n = n()) -> tab

# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Treat_mod,
           axis2 = TDuration)) +
  geom_alluvium(aes(fill = Treat_mod)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Treatment modality and duration of treatment")

```


## Treatment vs. Sex

```{r}
 # Treat_mod vs Design

dat_short %>% group_by(Treat_mod, Sex) %>%
  summarise(n = n()) -> tab
#alluvial(tab1[,1:2], freq = tab1$n)

# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Treat_mod,
           axis2 = Sex)) +
  geom_alluvium(aes(fill = Treat_mod)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Treatment modality and study setting")
```

## Treatment vs. Predator type

```{r}

# Treat_mod vs Design
dat_short %>% filter(PredTo != "") %>%
  group_by(Treat_mod, PredTo) %>%
  summarise(n = n()) -> tab

tab$PredTo <- factor(tab$PredTo, levels = c("A", "N", "B"), labels = c("Adult", "Nestling", "Both"))

#alluvial(tab1[,1:2], freq = tab1$n)

# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Treat_mod,
           axis2 = PredTo)) +
  geom_alluvium(aes(fill = Treat_mod)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Treatment modality and study setting")
```


## Treatment vs. Design

```{r}
 # Treat_mod vs Design

dat_short %>% group_by(Treat_mod, Design) %>%
  summarise(n = n()) -> tab
#alluvial(tab1[,1:2], freq = tab1$n)

# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Treat_mod,
           axis2 = Design)) +
  geom_alluvium(aes(fill = Treat_mod)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Treatment modality and study setting")
```

## Treatment vs. Season

```{r}
 # Treat_mod vs Design

dat_short %>% group_by(Treat_mod, Season) %>%
  summarise(n = n()) -> tab
#alluvial(tab1[,1:2], freq = tab1$n)

# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Treat_mod,
           axis2 = Season)) +
  geom_alluvium(aes(fill = Treat_mod)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Treatment modality and study setting")
```


## Treatment vs. Setting

```{r}
 # Treat_mod vs Design

dat_short %>% group_by(Treat_mod, Setting) %>%
  summarise(n = n()) -> tab
#alluvial(tab1[,1:2], freq = tab1$n)

# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Treat_mod,
           axis2 = Setting)) +
  geom_alluvium(aes(fill = Treat_mod)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Treatment modality and study setting")
```


## Treatment vs Control type

```{r}

# Treat_mod vs ControlType

dat_short %>% filter(ControlType != "mix") %>% group_by(Treat_mod, ControlType) %>%
  summarise(n = n()) -> tab
#alluvial(tab1[,1:2], freq = tab1$n)

# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Treat_mod,
           axis2 = ControlType)) +
  geom_alluvium(aes(fill = Treat_mod)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 6, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Treatment modality and control type")

```


## Trait type vs. Treatment duration
```{r}
# Type vs duration_days

# turn duration_days into a binary factor: less than 1 and more than 1

dat %>% mutate(TDuration = case_when(duration_days < 1 ~ "< 1 day",
                                          duration_days >= 1 ~ "> 1 day")) -> dat


dat %>% group_by(Type, TDuration) %>%
  summarise(n = n()) -> tab2

# using ggaruvial
ggplot(tab2,
       aes(y = n,
           axis1 = Type,
           axis2 = TDuration)) +
  geom_alluvium(aes(fill = Type)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Trait type and duration of treatment")

```

## Trait type vs. Sex
```{r}
# Type vs duration_days

# turn duration_days into a binary factor: less than 1 and more than 1

dat %>% mutate(TDration = case_when(duration_days < 1 ~ "< 1 day",
                                          duration_days >= 1 ~ "> 1 day")) -> dat

dat %>% group_by(Type, Sex) %>%
  summarise(n = n()) -> tab

# reordering
tab$Sex <- factor(tab$Sex, levels = c("F", "M", "both"), labels = c("Female", "Male", "Both"))


# using ggaruvial
ggplot(tab,
       aes(y = n,
           axis1 = Type,
           axis2 = Sex)) +
  geom_alluvium(aes(fill = Type)) +
  geom_stratum(alpha = 0.5) +
  geom_text(stat = "stratum", size = 4, aes(label = after_stat(stratum))) +
  theme(legend.position = "none") +
  theme(legend.position = "none",
        axis.text.x = element_blank()) + # remove x-axis labels
  ylab("Frequency") + 
  xlab("Trait type and duration of treatment")

```

:::

## Meta-analysis

::: {.panel-tabset}

## All random effects (one tree)

```{r}

# VCV matrix

VCV <- vcalc(vi = dat$Vd,
             cluster = dat$SubjectID,
             rho = 0.5)

mod_ma <- rma.mv(yi = SMD,
       V = VCV, 
       random = list(~1 | Phylo,
                     ~1 | Spp,
                     ~1 | RecNo,
                     ~1 | SubjectID,
                     ~1 | Obs_ID),
      R = list(Phylo = cor_tree),
       test = "t",
       method = "REML", 
       sparse = TRUE,
       data = dat)

summary(mod_ma)

# this could be added but not probably necessary
#robust(mod_ma, cluster = dat$SubjectID)

round(i2_ml(mod_ma), 2)

orchard_plot(mod_ma,
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)

```

## All random effects (50 trees)

```{r}
#| eval: false

# function to run the meta-analysis above

model_run <- function(cor_tree = vcv_tree){
  model <- rma.mv(yi = SMD,
       V = VCV, 
       random = list(~1 | Phylo,
                     ~1 | Spp,
                     ~1 | RecNo,
                     ~1 | SubjectID, 
                     ~1 | Obs_ID),
      R = list(Phylo = cor_tree),
       test = "t",
       method = "REML", 
       sparse = TRUE,
       data = dat)
  model
}

# creating 50 correlation matrixes from 50 different trees
vcv_tree_50 <- lapply(tree_50, function(x) vcv(x, corr = TRUE))

# running 50 meta-analyses with 50 different trees
# one can change mc.cores according to one's computer
ma_50 <- mclapply(vcv_tree_50, model_run, mc.cores = 18)

# saving the runs
saveRDS(ma_50, here("Rdata", "ma_50.RDS"))
```

```{r}
ma_50 <- readRDS(here("Rdata", "ma_50.RDS"))

# combining the results
est_50 <- map_dbl(ma_50, ~ .x$b[[1]])
se_50 <-  map_dbl(ma_50, ~ .x$se)
df_50 <- c(rbind(est_50, se_50))
  
# combine the data frames into an array
my_array <- array(df_50, dim = c(1, 2, 50))

# combining all the results from 50 models using Rubin's rules
pool.mi(my_array) 
```

## Reduced model

```{r}
# reduced model

mod_ma2 <- rma.mv(yi = SMD,
       V = VCV, 
       random = list(~1 | Spp,
                     ~1 | RecNo,
                     ~1 | Obs_ID),
       test = "t",
       method = "REML", 
       sparse = TRUE,
       data = dat)

summary(mod_ma2)

round(i2_ml(mod_ma2), 2)

# comparing two models
#anova(mod0, mod0r)
```

:::

## Meta-regression: uni-moderator

::: {.panel-tabset}

## Treatmeant with all data

```{r}

mod_trt <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1 | Spp,
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mod = ~ Treat_mod - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)

summary(mod_trt)

round(r2_ml(mod_trt)*100, 2)

orchard_plot(mod_trt, 
             mod = "Treat_mod",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)

# result table
all_models(mod_trt, mod = "Treat_mod")
```

## Treatment with Audio and Visual data


```{r}

# prep

dat_short$Treat_mod <- factor(dat_short$Treat_mod, levels = rev(c("A", "V", "AV")))

#homoscedastic model

VCVs <- vcalc(vi = dat_short$Vd,
             cluster = dat_short$SubjectID,
             rho = 0.5)


mod_trt_1 <- rma.mv(yi = SMD,
                   V = VCVs,
                   random = list(~1| Spp,
                                 ~1 | RecNo,
                                 ~1 | Obs_ID),
                   mod = ~ Treat_mod - 1, 
                   test = "t",
                   method = "REML", 
                   sparse = TRUE,
                   data = dat_short)

summary(mod_trt_1)

round(r2_ml(mod_trt_1)*100, 2)

orchard_plot(mod_trt_1, 
             mod = "Treat_mod",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)

# result table (get all the constrasts)
all_models(mod_trt_1, mod = "Treat_mod")

# modeling heteroscedasticity
mod_trt_2 <- rma.mv(yi = SMD, 
                V = VCVs, 
                random = list(~1|Spp , 
                              ~1 | RecNo, 
                              ~ Treat_mod | Obs_ID), 
                mod = ~ Treat_mod - 1, 
                test = "t",
                struct = "DIAG",
                method = "REML", 
                sparse = TRUE,
                data = dat_short)

summary(mod_trt_2)

orchard_plot(mod_trt_2, 
             mod = "Treat_mod",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)

# result table (get all the constrasts)
all_models(mod_trt_2, mod = "Treat_mod")

# comparison models
anova(mod_trt_1, mod_trt_2) # modeling heteroscedasticity is better 
```

## Treatment with additions

```{r}
# the effect of additions
# this is a part of sensitivity analysis

dat_short_add$Treat_add <- as.factor(paste(dat_short_add$Treat_mod , 
                                 dat_short_add$Add_on, 
                                 sep = "-"))

VCVs2 <- vcalc(vi = dat_short_add$Vd,
             cluster = dat_short_add$SubjectID,
             rho = 0.5)

mod_add <- rma.mv(yi = SMD, 
                V = VCVs2, 
                random = list(~1|Spp , 
                              ~1 | RecNo, 
                              ~ 1 | Obs_ID), 
                mod = ~ Treat_add - 1,
                test = "t",
                struct = "DIAG",
                method = "REML", 
                sparse = TRUE,
                data = dat_short_add)

summary(mod_add) 

orchard_plot(mod_add, 
             mod = "Treat_add",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)

# result table (get all the constrasts)
all_models(mod_add, mod = "Treat_add")
```

## Treatment as an ordinal variable

```{r}
# testing the number of stimuli

mod_ord <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1|Spp , 
                             ~1 | RecNo, 
                             ~1 | Obs_ID), 
               mod = ~ Treat_No, 
               test = "t",
               method = "REML", 
               sparse = TRUE,
               data = dat)

summary(mod_ord)

bubble_plot(mod_ord,
             mod = "Treat_No",
             group = "RecNo",
             xlab = "The number of simuli",
             g = TRUE)

```

## Trait type

```{r}
#homoscedastic model
# Type of responses 
mod_type1 <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1 | Spp,
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mod = ~ Type - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)

summary(mod_type1)

round(r2_ml(mod_type1)*100, 2)

ptype1 <- orchard_plot(mod_type1,
             mod = "Type",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)
ptype1

# result table
all_models(mod_type1, mod = "Type")

# heteroscadasticity model
mod_type2 <- rma.mv(yi = SMD, 
               V = VCV, 
               mod = ~ Type - 1, 
               random = list(~1|Spp , 
                             ~1 | RecNo, 
                             ~Type | Obs_ID), 
               struct = "DIAG",
               test = "t",
               method = "REML", 
               sparse = TRUE,
               data = dat)

summary(mod_type2)

ptype2 <- orchard_plot(mod_type2, 
             mod = "Type",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)

ptype2
# result table
all_models(mod_type2, mod = "Type")

# heteroscadasticity model better than the homoscedasticity model
# note LifeHistory has lowest variation but this may be expected? 
# as it is less flexiable (e.g. the number of eggs?)
anova(mod_type1, mod_type2)
```


## Treatment duration

```{r}

# treatment duration

dat$ln_duration <- log(dat$duration_days)

mod_dur <- rma.mv(yi = SMD,
               V = VCV,
               random = list(~1|Spp,
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ ln_duration,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)
summary(mod_dur)


round(r2_ml(mod_dur)*100, 2)

bubble_plot(mod_dur,
             mod = "ln_duration",
             group = "RecNo",
             xlab = "log(duration in days)",
             g = TRUE) +
    geom_point(data = dat,
    aes(x = ln_duration, y = SMD,
    color = Type,
    fill = Type,
    size = 1/sqrt(Vd)), alpha = 0.6) +
    scale_color_discrete() + 
    guides(color = "legend")

#p + geom_point(aes(colour = Type))
#scale_colour_manual(values = c("red", "blue", "green"))

# extra  - looking at the interaction
mod_dur_int <- rma.mv(yi = SMD,
               V = VCV,
               random = list(~1|Spp,
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ ln_duration*Type,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)

# no significant interaction
summary(mod_dur_int)

res<-mod_results(mod_dur_int, mod = "ln_duration", group = "RecNo", by = "Type")

bubble_plot(res,
             mod = "ln_duration",
             group = "RecNo",
             xlab = "log(duration in days)",
             condition.nrow = 3,
             g = TRUE) 
```

## Sex

```{r}
# sex

mod_sex1 <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ Sex - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)
summary(mod_sex1)

round(r2_ml(mod_sex1)*100, 2)

orchard_plot(mod_sex1,
             mod = "Sex",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_sex1, mod = "Sex")

# heteroscedasticity

mod_sex2 <- rma.mv(yi = SMD, 
                V = VCV, 
                mod = ~ Sex - 1, 
                random = list(~1|Spp , 
                              ~1 | RecNo, 
                              ~Sex | Obs_ID), 
                struct = "DIAG",
                test = "t",
                method = "REML", 
                sparse = TRUE,
                data = dat)

summary(mod_sex2)


orchard_plot(mod_sex2,
             mod = "Sex",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_sex2, mod = "Sex", type = "hetero")


anova(mod_sex1, mod_sex2)
```


## Trait categories

```{r}
# Category of responses


mod_cat <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1|Spp , 
                             ~1 | RecNo, 
                             ~1 | Obs_ID), 
               mod = ~ Category - 1, 
               test = "t",
               method = "REML", 
               sparse = TRUE,
               data = dat)

summary(mod_cat)

round(r2_ml(mod_cat)*100, 2)


orchard_plot(mod_cat, 
             mod = "Category",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             angle = 45,
             branch.size = 3)

# result table
all_models(mod_cat, mod = "Category")
```

## Predactor guild

```{r}
# Redactor guild
# Fish only N = 1 so remove and also remove NS (not specified)

dat %>% filter(PredGuild != "Fish" & PredGuild != "NS") ->
  data_preg

VCVs3 <- vcalc(vi = data_preg$Vd,
             cluster = data_preg$SubjectID,
             rho = 0.5)

mod_preg <- rma.mv(yi = SMD, 
               V = VCVs3, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ PredGuild - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = data_preg)

summary(mod_preg)

round(r2_ml(mod_preg)*100, 2)
# R2_marginal R2_conditional 
#           1.70          19.62 

orchard_plot(mod_preg, 
             mod = "PredGuild",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_preg, mod = "PredGuild")

```

## Setting

```{r}
# Setting

mod_set <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ Setting - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)

summary(mod_set)

round(r2_ml(mod_set)*100, 2)
# R2_marginal R2_conditional 
#           0.70          18.98 

orchard_plot(mod_set, 
             mod = "Setting",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_set, mod = "Setting")
```

## Season

```{r}
# Season
mod_4 <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ Season - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)


summary(mod_4)

round(r2_ml(mod_4)*100, 2)

orchard_plot(mod_4,
             mod = "Season",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")


# result table
all_models(mod_4, mod = "Season")
```

## Design

```{r}
# Design
mod_d <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ Design - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)
summary(mod_d)

round(r2_ml(mod_d)*100, 2)
 # R2_marginal R2_conditional 
 #          0.01          18.72 

orchard_plot(mod_d,
             mod = "Design",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_d, mod = "Design")
```

## Response period

```{r}
# Response period
mod_resp <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ ResponsePeriod - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)
summary(mod_resp)

round(r2_ml(mod_resp)*100, 2)
#   R2_marginal R2_conditional 
#          0.61          19.10 


orchard_plot(mod_resp,
             mod = "ResponsePeriod",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_resp, mod = "ResponsePeriod")
```

## Control type

```{r}
# control type
# Mix only N = 1 so remove 

dat %>% filter(ControlType != "mix") ->
  data_cont

VCVs4 <- vcalc(vi = data_cont$Vd,
             cluster = data_cont$SubjectID,
             rho = 0.5)

mod_cont <- rma.mv(yi = SMD, 
               V = VCVs4, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ ControlType - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = data_cont)
summary(mod_cont)

round(r2_ml(mod_cont)*100, 2)
# R2_marginal R2_conditional 
#           0.07          18.73 

orchard_plot(mod_cont,
             mod = "ControlType",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_cont, mod = "ControlType")

```


## Age

```{r}
# age
#A = Adult, N = Nestling, J = Juveniles (including fledglings and first year birds), E = Egg

# "" only N = 2 (study = 1) so remove 

dat %>% filter(Age != "") ->
  dat_age

VCVs5 <- vcalc(vi = dat_age$Vd,
             cluster = dat_age$SubjectID,
             rho = 0.5)


# age
mod_age <- rma.mv(yi = SMD, 
               V = VCVs5, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ Age - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat_age)
summary(mod_age)

round(r2_ml(mod_age)*100, 2)
   # R2_marginal R2_conditional 
   #        0.15          18.74 

orchard_plot(mod_age,
             mod = "Age",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_age, mod = "Age")
```

## Predactor type

```{r}
# type of predator

dat$PredTo[dat$PredTo == ""] <- NA



mod_predt <- rma.mv(yi = SMD, 
               V = VCV, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ PredTo - 1,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat)
summary(mod_predt)

round(r2_ml(mod_predt)*100, 2)
# R2_marginal R2_conditional 
#           0.25          18.97 


orchard_plot(mod_predt,
             mod = "PredTo",
             group = "RecNo",
             xlab = "Standardised mean differnece (SMD)")

# result table
all_models(mod_predt, mod = "PredTo")

```


:::

## Meta-regression: multi-moderator


```{r}
#######################
# Mulit-variable models
#######################

dat_short$sln_duration <- scale(log(dat_short$duration_days))

mod_full <- rma.mv(yi = SMD, 
               V = VCVs, 
               random = list(~1|Spp , 
                             ~1 | RecNo,
                             ~1 | Obs_ID),
               mods =  ~ sln_duration*Type +
                         sln_duration*Treat_mod +
                         Sex,
               test = "t",
               method = "REML",
               sparse = TRUE,
               data = dat_short)
summary(mod_full)

round(r2_ml(mod_full)*100, 2)

orchard_plot(mod_full,
             mod = "Type",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)

orchard_plot(mod_full,
             mod = "Treat_mod",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3)

# interaction plot of duration with trait types
int_type <- mod_results(mod_full, mod = "sln_duration", group = "RecNo", weights = "prop",
                                   by = "Type")

bubble_plot(int_type, group = "RecNo", mod = "sln_duration", xlab = "ln(duration in days) (z-transformed)",
                     legend.pos = "top.left", condition.nrow = 3, g = TRUE)

# interaction plot of duration with trait types
int_trt <- mod_results(mod_full, mod = "sln_duration", group = "RecNo", weights = "prop",
                        by = "Treat_mod")

bubble_plot(int_trt, group = "RecNo", mod = "sln_duration", xlab = "ln(duration in days)",
            legend.pos = "top.left", condition.nrow = 3, g = TRUE)
```

```{r}
# mulit-model selection
candidates <- dredge(mod_full, trace = 2)

# displays delta AICc <2
candidates_aic2 <- subset(candidates, delta < 5) 
# model averaging
mr_averaged_aic2 <- summary(model.avg(candidates, delta < 5)) 

# relative importance of each predictor for all the models
importance <- sw(candidates)
```

## Publication bias and sensitivty analyses

::: {.panel-tabset}

## Funnel plot: uni-moderator

```{r}
funnel(mod_ma2, 
       yaxis="seinv",
       # = "rstudent",
       xlab = "Standarized residuals",
       ylab = "Precision (inverse of SE)",
       ylim = c(0.001, 16),
       xlim = c(-10,15),
       digits=c(0,1)
       )

```

## Funnel plot: multi-moderator

```{r}
fun2 <- funnel(mod_full, 
       yaxis="seinv",
       #type = "rstudent",
       xlab = "Standarized residuals",
       ylab = "Precision (inverse of SE)",
       ylim = c(0.001, 1.5),
       xlim = c(-5,10),
       digits=c(0,1)
       )

fun2
```

## Egger regression: uni-moderator

```{r}
# Egger

dat$effectN <- (dat$Ncontrol * dat$NTreat) / (dat$Ncontrol + dat$NTreat)
dat$sqeffectN <- sqrt(dat$effectN)

mod_mae <- rma.mv(yi = SMD,
                V = VCV,
                mods = ~ sqeffectN,
                random = list(
                  ~1 | Spp,
                  ~1 | RecNo,
                  ~1 | Obs_ID),
                test = "t",
                method = "REML", 
                sparse = TRUE,
                data = dat)

summary(mod_mae)

small <- bubble_plot(mod_mae,
            mod = "sqeffectN",
            group = "RecNo",
            xlab = "Effective N",
            ylab = "Standardized mean difference (SMD)",
            g = TRUE)

small
```

## Decline effect: uni-moderator

```{r}
# decline effect
mod_mad <- rma.mv(yi = SMD,
                V = VCV,
                mods = ~ Year,
                random = list(
                  ~1 | Spp,
                  ~1 | RecNo,
                  ~1 | Obs_ID),
                test = "t",
                method = "REML", 
                sparse = TRUE,
                data = dat)

summary(mod_mad)

decline <- bubble_plot(mod_mad,
            mod = "Year",
            group = "RecNo",
            xlab = "Publication year",
            ylab = "SMD (effect size)",
            g = TRUE)
decline
```

## All together

```{r}
# full model
dat_short$effectN <- (dat_short$Ncontrol * dat_short$NTreat) / (dat_short$Ncontrol + dat_short$NTreat)
dat_short$sqeffectN <- sqrt(dat_short$effectN)

mod_fulle <- rma.mv(yi = SMD, 
                   V = VCVs, 
                   random = list(~1|Spp , 
                                 ~1 | RecNo,
                                 ~1 | Obs_ID),
                   mods =  ~ sqeffectN +
                     Year +
                     sln_duration*Type +
                     sln_duration*Treat_mod +
                     Sex,
                   test = "t",
                   method = "REML",
                   sparse = TRUE,
                   data = dat_short)
summary(mod_fulle)

# small-study
bubble_plot(mod_fulle, group = "RecNo", mod = "sqeffectN", xlab = "ln(duration in days)",
            legend.pos = "top.left", condition.nrow = 3, g = TRUE)

# decline
bubble_plot(mod_fulle, group = "RecNo", mod = "Year", xlab = "ln(duration in days)",
            legend.pos = "top.left", condition.nrow = 3, g = TRUE)

```

## Leave-1study-out (sensitivity analysis)

```{r}
#| eval: false

dat <- dat %>%
    mutate(leave_out = paste(Author, Year, sep = "_"))
dat$leave_out <- as.factor(dat$leave_out)


LeaveOneOut_effectsize <- list()
for (i in 1:length(levels(dat$leave_out))) {
    temp_dat <- dat %>%
        filter(leave_out != levels(dat$leave_out)[i])

    VCV_leaveout <- vcalc(vi = temp_dat$Vd, cluster = temp_dat$SubjectID, rho = 0.5)

    LeaveOneOut_effectsize[[i]] <-  rma.mv(yi = SMD,
       V = VCV_leaveout, 
       random = list(#~1 | Phylo,
                     ~1 | Spp,
                     ~1 | RecNo,
                     #~1 | SubjectID,
                     ~1 | Obs_ID),
       R = list(Phylo = cor_tree),
       test = "t",
       method = "REML", 
       sparse = TRUE,
       data = temp_dat[temp_dat$leave_out != levels(temp_dat$leave_out)[i], ])
}

# writing function for extracting est, ci.lb, and ci.ub from all models
est.func <- function(model) {
    df <- data.frame(est = model$b, lower = model$ci.lb, upper = model$ci.ub)
    return(df)
}

# using dplyr to form data frame
MA_oneout <- lapply(LeaveOneOut_effectsize,function(x) est.func(x)) %>%
    bind_rows %>%
    mutate(left_out = levels(dat$leave_out))


# telling ggplot to stop reordering factors
MA_oneout$left_out <- as.factor(MA_oneout$left_out)
MA_oneout$left_out <- factor(MA_oneout$left_out, levels = MA_oneout$left_out)

# saving the runs
saveRDS(MA_oneout, here("Rdata", "MA_oneout.RDS"))

```

```{r}
MA_oneout <- readRDS(here("Rdata", "MA_oneout.RDS"))

# plotting
leaveoneout <- ggplot(MA_oneout) + geom_hline(yintercept = 0, lty = 2, lwd = 1) +
    geom_hline(yintercept = mod_ma2$ci.lb, lty = 3, lwd = 0.75, colour = "black") +
    geom_hline(yintercept = mod_ma2$b, lty = 1, lwd = 0.75, colour = "black") + 
    geom_hline(yintercept = mod_ma2$ci.ub,
    lty = 3, lwd = 0.75, colour = "black") + 
    geom_pointrange(aes(x = left_out, y = est,
    ymin = lower, ymax = upper)) + 
     xlab("Study left out") + 
     ylab("SMD (effect size), 95% CI") +
    coord_flip() + 
    theme(panel.grid.minor = element_blank()) + theme_bw() + theme(panel.grid.major = element_blank()) +
    theme(panel.grid.minor.x = element_blank()) + theme(axis.text.y = element_text(size = 6))

leaveoneout

```



:::

## Figure gallery

::: {.panel-tabset}

## Figure: phylogeny and world map

```{r}
#| eval: false

slist <- read_excel(here("data", "Species list.xlsx"))

slist %>% mutate_if(is.character, as.factor) ->slist

dat2 <- dat %>% group_by(Spp) %>% 
  summarise(N_obs = n())

dat2$Spp <- gsub("_", " ",dat2$Spp)

slist$Species_L <- gsub("_", " ", slist$Species_L)

# change tip label
tree$tip.label <-  gsub("_", " ", tree$tip.label)

phy_fig1 <- ggtree(tree, branch.length = "branch.length") 

#phy_fig1

phy_fig2 <- phy_fig1 %<+% slist + geom_tiplab(size=2,fontface = "italic") + 
  geom_tippoint() + 
  xlim_expand(c(0,120), panel = "Tree") #+ guides(color="none")  


phy_fig3 <- facet_plot(phy_fig2, panel = 'k (effect sizes)', data = dat2, 
				geom = geom_barh, 
				mapping = aes(x = N_obs), alpha = 0.7, stat='identity') + 
        
  # geom_facet(panel = "Estimates of mean ratio (lnRR)", data = re.spp.lnRR2,
  #          geom = geom_barh, 
  #          mapping =  aes(x = N_obs, fill=Family, color=Family), alpha = 0.4, stat='identity') + 
  
        guides(fill="none",color="none") + 
        theme_tree2() + theme(strip.background = element_rect(fill = "white"))

phy_fig4 <-  facet_widths(phy_fig3, widths = c(0.7, 0.3))

# adding incons
filenames <- list.files("images", pattern=".png", full.names=TRUE)
ldf <- purrr::map(filenames,~readPNG(.x))
names(ldf) <- substr(filenames, 8, 60)
ldf <- purrr::map(ldf, ~image_negate(image_read(.x)))
#ldf <- map(ldf, ~ image_blank(nrow(.x), ncol(.x), color = "black"))
#ldf <- lapply(ldf, raster)

# this works but does not knit
phy_fig5 <- ggdraw(phy_fig4) +
  draw_image(ldf$Anseriformes.png, y = 0.4, x = -0.45, scale = 0.05)  +
  draw_image(ldf$Charadriiformes.png, y = 0.4, x = -0.4, scale = 0.05) +
  draw_image(ldf$Columbiformes.png, y = 0.4, x = -0.35, scale = 0.05) +
  draw_image(ldf$Coraciiformes.png, y = 0.35, x = -0.45, scale = 0.05) +
  draw_image(ldf$Falconiformes.png, y = 0.35, x = -0.4, scale = 0.05) +
  draw_image(ldf$Galliformes.png, y = 0.35, x = -0.35, scale = 0.05) +
  draw_image(ldf$Gruiformes.png, y = 0.3, x = -0.45,scale = 0.05) +
  draw_image(ldf$Passeriformes.png, y = 0.3, x = -0.4,scale = 0.05) +
  draw_image(ldf$Piciformes.png, y = 0.3, x = -0.35, scale = 0.05) +
  draw_image(ldf$Procellariiformes.png, y = 0.25, x = -0.45,scale = 0.05) +
  draw_image(ldf$Strigiformes.png, y = 0.25, x = -0.4, scale = 0.05) #+
  #draw_image(ldf$Strigiformes.png, y = 0.25, x = -0.35,scale = 0.05) 
  
#phy_fig5

# colouring
# phy_fig2 <- phy_fig1 %<+% slist + geom_tiplab(aes(color  = Family),size=3,fontface = "italic") + geom_tippoint(aes(color=Family)) + xlim_expand(c(0,120), panel = "Tree") + guides(color="none")  
# 
# phy_fig2
# 
# phy_fig3 <- facet_plot(phy_fig2, panel = 'k (effect sizes)', data = dat2, 
# 				geom = geom_barh, 
# 				mapping = aes(x = N_obs, fill=Family, color=Family), alpha = 0.4, stat='identity') + 
#         
#   # geom_facet(panel = "Estimates of mean ratio (lnRR)", data = re.spp.lnRR2,
#   #          geom = geom_barh, 
#   #          mapping =  aes(x = N_obs, fill=Family, color=Family), alpha = 0.4, stat='identity') + 
#   
#         guides(fill="none",color="none") + 
#         theme_tree2() + theme(strip.background = element_rect(fill = "white"))
# 
# phy_fig4 <-  facet_widths(phy_fig3, widths = c(0.7, 0.3))
# 
# phy_fig4

# reading in country data

clist <- read_excel(here("data", "StudyCountries.xlsx"))

#clist %>% mutate_if(is.character, as.factor) -> clist

cdat <- clist %>% group_by(StudyCountry) %>% 
  summarise(N_obs = n())

cdat$region <- cdat$StudyCountry
cdat$n <- cdat$N_obs
cdat <- cdat[, 3:4]
#cdat$region <- as()

# need to tell 
cdat$region[cdat$region == "England"] <- "UK" 
cdat$region[cdat$region == "Scotland"] <- "UK" 
cdat$region[cdat$region == "Kerguelen Islands"] <- "France"
cdat$region[cdat$region == "Republic of Korea"] <- "South Korea"

#https://www.riinu.me/2022/02/world-map-ggplot2/

world_map <- map_data("world") %>% 
  filter(! long > 180) #remove countries with longitude >180 to make equal projection-like map without artifacts

#which(is.na(match(cdat$region, world_map$region)) == T)
#cdat$region[which(is.na(match(cdat$region, world_map$region)) == T)]

## colour all regions on the map:

emptymap <- world_map %>% group_by(region) %>% 
  summarise(N_obs = n(), long = mean(long), lat = mean(lat))

emptymap$n <- 0

# emptymap <- tibble(region = unique(world_map$region), 
#                    n = rep(0,length(unique(world_map$region)))) #create table with all counts as 0
fullmap <- left_join(emptymap, cdat, by = "region") #join with actual counts table
fullmap$n <- fullmap$n.x + fullmap$n.y # make new column for fixed counts
fullmap$n[is.na(fullmap$n)] <- 0 #change NA to 0 for regions with no counts

map_fig <- fullmap %>% 
  ggplot(aes(fill = n, map_id = region)) +
  geom_map(map = world_map) +
  expand_limits(x = world_map$long, y = c(-50, 80)) +
  #coord_map("moll") +
  theme_map() + 
  theme(legend.position="right") +
  #geom_text(aes(x = long, y = lat, label = n), size = 3, color = "black") +
  scale_fill_gradient(low = "#FEE08B", high = "#D53E4F",
                      #low = "white", high = "red",
                      limits = c(1, 30),
      guide = guide_colorbar(direction = "vertical.")) +
  guides(fill = guide_colourbar(barwidth = unit(15, units = "mm"), barheight = unit(20, units = "mm")))  +
  theme(legend.position = c(0.05, 0.2))


#map_fig

phy_fig5 / map_fig +  plot_annotation(tag_levels = 'A') + plot_layout(heights = c(2.5,1.0))

```
![](../figs/phy_map.png)

## Figure: main and different modality

```{r}

#cbpl <- c("#88CCEE", "#CC6677", "#DDCC77", "#117733", "#332288", "#AA4499", "#44AA99", "#999933", "#882255", "#661100", "#6699CC", "#888888", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#999999")

# merging results of different models

main <- mod_results(mod_ma, group = "RecNo")
treat5 <- mod_results(mod_trt, mod = "Treat_mod", group = "RecNo")

combined <- submerge(treat5, main)

combo <- orchard_plot(combined,
             #mod = "Type",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3) +
          scale_colour_manual(values = rep("grey20",7)) +
          scale_fill_manual(values = c("#117733", "#332288", "#AA4499", "#88CCEE", "#CC6677", "#DDCC77", "#999999"), ) 
          
homo_mod <- orchard_plot(mod_trt_1, 
             mod = "Treat_mod",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3,
             legend.pos = "none") + 
          scale_colour_manual(values = rep("grey20",3))

hetero_mod <- orchard_plot(mod_trt_2, 
             mod = "Treat_mod",
             group = "RecNo", 
             xlab = "Standardised mean differnece (SMD)",
             branch.size = 3,
			       legend.pos = "none") + 
          scale_colour_manual(values = rep("grey20",3))

patch <- combo | (homo_mod / hetero_mod)

patch +  plot_annotation(tag_levels = 'A') 

```

## Figure: different moderators

```{r}

#cbpl <- c("#88CCEE", "#CC6677", "#DDCC77", "#117733", "#332288", "#AA4499", "#44AA99", "#999933", "#882255", "#661100", "#6699CC", "#888888", "#E69F00", "#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7", "#999999")

ptype2 <- ptype2 +
          scale_colour_manual(values = rep("grey20",3))

bub_dr <- bubble_plot(mod_dur,
             mod = "ln_duration",
             group = "RecNo",
             xlab = "log(duration in days)",
             ylab = "Standardised mean differnece (SMD)",
             g = TRUE,
             legend.pos = "bottom.left") +
    #ylim(-10, 10) +
    geom_point(data = dat,
    aes(x = ln_duration, y = SMD,
    color = Type,
    fill = Type,
    size = 1/sqrt(Vd)), alpha = 0.6,
    shape = 21) +
    scale_color_discrete() + 
    scale_shape_manual(values = c(21, 22, 23)) +
    scale_fill_manual(values = c("#88CCEE", "#CC6677", "#DDCC77")) +
    scale_colour_manual(values = rep("grey20",3)) +
    guides(fill = "legend", size = "none", colour = "none")
    
patch2 <- ptype2 / bub_dr

patch2 +  plot_annotation(tag_levels = 'A') 
```

## Figure: publication bias

```{r}
pdf(NULL)
dev.control(displaylist="enable")
par(mar=c(4,4,0.1,0) + 0.1)
funnel(mod_ma2, 
       yaxis="seinv",
       # = "rstudent",
       pch = 1,
       cex = 0.7,
       #bg = "white",
       xlab = "Standarized residuals",
       ylab = "Precision (inverse of SE)",
       ylim = c(0.001, 16),
       xlim = c(-10,15),
       digits=c(0,1)
       )
fun <- recordPlot()
invisible(dev.off())	   

pub_b <- ggdraw(fun)  / plot_grid(small) / plot_grid(decline)
pub_b +  plot_annotation(tag_levels = 'A') 
```


:::

## R Session Informtion

```{r}
# pander for making it look nicer
sessionInfo() %>% pander()
```



